## 动态规划DP

当一个问题可以用递归求解的时候，我们就可以试试动态规划求解

递归是自顶向下的把问题分解成子问题，直到不可分割，不可分割的最小问题的解是显然的，然后把子问题的结果合并得到原问题的解

递归的要素：

* 对子问题的分解方法
* 最小子问题和对应的解
* 合并子问题的解的方法

```python
def 递归(问题参数):
    if 问题是最小子问题:
        return 对应的解
    
    子问题参数包=问题分解(问题参数,当前上下文)

    results=[]
    for 子问题参数 in 子问题参数包:
        results.append(递归(子问题参数))
    
    return 合并(results)
```

动态规划则反过来，自底向上的从`最小子问题和对应的解`不断向上合并，直到得到`问题参数`对应的解，可以发现其要素和递归是一模一样的（其实还有不同，下面说）

```python
dp={}
def 动态规划(问题参数):
    dp[最小子问题参数]=对应的解
    最小问题参数=比最小子问题稍大的问题
    for 参数 in range(最小问题参数,问题参数):
        子问题参数包=问题分解(参数,当前上下文)
        results=dp[子问题参数包]
        dp[参数]=合并(results)
    
    return dp[问题参数]
```

不同点：

* 动态规划中每个子问题只被求解一次，节省时间
* 动态规划中每个问题被求解时必须保证其子问题已被求解，所以求解顺序很重要，也是很多问题的难点

### 动态规划的空间占用优化

dp中一直保存着已经计算出来的所有子问题的解，有的时候计算到后期，前期的子问题的解根本就用不上，完全可以扔掉

例如计算斐波那契数列 dp[n]=dp[n-1]+dp[n-2]
计算一个子问题的时候最多就用上前两个子问题的解

那么我们只在dp中存着dp[n]和dp[n-1]即可计算dp[n+1],也就是说dp的空间为2即可，得到dp[n+1]的时候就把dp[n-1]扔掉，比起常规状态dp空间为n省多了